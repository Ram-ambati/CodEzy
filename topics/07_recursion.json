{
  "id": "recursion",
  "order": 7,
  "title": "Recursion",
  "description": "Learn how functions can call themselves - the power and the pitfalls",
  "difficulty": "advanced",
  "icon": "ðŸ”—",
  "estimatedTime": "35 min",
  "xpReward": 250,
  "concepts": [
    {
      "id": "rec_intro",
      "title": "What is Recursion?",
      "content": "Recursion is a powerful programming technique where a function calls itself to solve a problem by breaking it into smaller subproblems of the same type. The concept might sound strange at firstâ€”how can a function help solve a problem by calling itself?â€”but it's a natural and elegant solution for certain classes of problems.\n\nConsider a classic example: calculating factorial. The factorial of n (written as n!) is the product of all positive integers less than or equal to n. So 5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120. You could calculate this with a loop, but there's an elegant recursive definition: factorial(n) = n Ã— factorial(n-1). This is recursive because the definition refers to itself with a simpler input.\n\nThe key insight is that if you can break down a problem into smaller instances of the same problem, you can solve it recursively. The function calls itself with simpler input until it reaches a case so simple it can be solved directly without recursion. This is called the base case.\n\nRecursion appears naturally in many programming problems. Tree traversal, graph exploration, parsing nested structures, divide-and-conquer algorithms, and backtracking all use recursion naturally. Many problems are actually easier to think about and implement recursively than iteratively (using loops).\n\nHowever, recursion has both advantages and disadvantages. Advantages include cleaner, more intuitive code that mirrors the problem structure, and easier implementation of certain algorithms. Disadvantages include overhead from function calls and the risk of stack overflow if recursion goes too deep. Despite the overhead, for most practical problems, the elegance and simplicity of recursion outweigh the performance cost.\n\nUnderstanding recursion deeply is important for becoming a truly competent programmer. It's a fundamental tool in computer science, used in countless algorithms and data structures. While it might seem mysterious now, with practice it becomes second nature.",
      "codeExample": "// Simple factorial example\nint factorial(int n) {\n    if (n <= 1) return 1;           // BASE CASE\n    return n * factorial(n - 1);    // RECURSIVE CALL\n}\n\n// Usage\nfactorial(5);  // Returns 120 (5*4*3*2*1)\nfactorial(1);  // Returns 1 (base case)\nfactorial(0);  // Returns 1 (base case)\n\n// Trace of factorial(3):\n// factorial(3) = 3 * factorial(2)\n// factorial(2) = 2 * factorial(1)\n// factorial(1) = 1 (base case)\n// Working back: 2 * 1 = 2, then 3 * 2 = 6",
      "visualization": {
        "type": "trace",
        "title": "Factorial Recursion Trace",
        "description": "Step-by-step execution of factorial(3)",
        "data": {
          "steps": [
            {"line": 1, "code": "factorial(3)", "variables": {"n": 3}},
            {"line": 2, "code": "3 * factorial(2)", "variables": {"n": 2}},
            {"line": 3, "code": "2 * factorial(1)", "variables": {"n": 1}},
            {"line": 4, "code": "Return 1 (base case)", "variables": {"result": 1}},
            {"line": 5, "code": "2 * 1 = 2", "variables": {"result": 2}},
            {"line": 6, "code": "3 * 2 = 6", "variables": {"result": 6}}
          ]
        }
      }
    },
    {
      "id": "rec_structure",
      "title": "Structure of Recursion",
      "content": "Every successful recursive function has three essential components that work together to solve problems elegantly.\n\nFirst, the base case. This is the condition that stops the recursion. Without a base case, the function would call itself infinitely, causing a stack overflow error. The base case is usually the simplest version of the problemâ€”something so trivial that it can be solved without recursion. For factorial, the base case is n <= 1, which returns 1 directly. For a countdown, the base case is n == 0, which simply returns without doing anything.\n\nSecond, the recursive case. This is where the function calls itself with a simpler or smaller version of the original problem. The key is that each recursive call must progress toward the base case. For factorial, the recursive case is n * factorial(n-1)â€”we multiply by n and recursively solve for n-1, which is simpler. For countdown, the recursive case prints the current number and then calls countdown(n-1).\n\nThird, progress toward the base case. This is crucial. Each recursive call must modify the parameters in a way that moves toward the base case. If factorial(n) called factorial(n) instead of factorial(n-1), it would recurse infinitely. Progress ensures that eventually, the base case is reached.\n\nThe combination of these three elements is what makes recursion work. You define what to do for the base case (trivial), you define how to solve a larger problem by breaking it into smaller problems of the same type, and you ensure that each step makes progress toward the base case.\n\nPractical example: binary search. The base case is when the search space is empty (not found). The recursive case divides the search space in half and recursively searches the appropriate half. Each call has a smaller search space, progressing toward the base case.\n\nWhen designing a recursive function, think about: What's the simplest case I can solve directly? How can I break the problem into a smaller version of itself? How do I guarantee progress toward the simplest case?",
      "codeExample": "// Countdown with clear structure\nvoid countdown(int n) {\n    // BASE CASE\n    if (n == 0) {\n        printf(\"Blastoff!\\n\");\n        return;\n    }\n    \n    // RECURSIVE CASE\n    printf(\"%d \", n);\n    countdown(n - 1);  // Progress: n-1 is closer to base case\n}\n\n// Power function: compute base^exp\nint power(int base, int exp) {\n    // BASE CASE: anything to power 0 is 1\n    if (exp == 0) return 1;\n    \n    // RECURSIVE CASE: base^exp = base * base^(exp-1)\n    return base * power(base, exp - 1);\n}\n\n// Sum array elements recursively\nint sumArray(int arr[], int n) {\n    // BASE CASE: empty array sums to 0\n    if (n == 0) return 0;\n    \n    // RECURSIVE CASE: sum = last element + sum of rest\n    return arr[n-1] + sumArray(arr, n-1);\n}",
      "visualization": {
        "type": "table",
        "title": "Recursive Function Components",
        "description": "Essential parts of every recursive function",
        "config": {
          "columns": ["component", "purpose", "example"],
          "columnLabels": ["Component", "Purpose", "Example"]
        },
        "data": {
          "rows": [
            {"component": "Base Case", "purpose": "Stops recursion", "example": "if (n <= 1) return 1;"},
            {"component": "Recursive Case", "purpose": "Calls itself", "example": "return n * factorial(n-1);"},
            {"component": "Progress", "purpose": "Reaches base case", "example": "n-1 moves closer to 0"}
          ]
        }
      }
    },
    {
      "id": "rec_call_stack",
      "title": "Call Stack",
      "content": "Understanding how the call stack works is essential for understanding recursion. The call stack is a special region of memory that keeps track of function calls.\n\nWhen a function is called, a new frame (or activation record) is created on the call stack. This frame contains space for the function's local variables, parameters, and return address. When the function returns, its frame is removed from the stack.\n\nWith recursion, multiple frames accumulate on the stack. Consider factorial(3): when it calls factorial(2), a new frame is pushed onto the stack. When factorial(2) calls factorial(1), another frame is pushed. When factorial(1) hits the base case and returns, its frame is popped. Then factorial(2) completes and its frame is popped. Finally, factorial(3) completes and its frame is popped.\n\nThis stacking and unstacking of frames is completely automaticâ€”the computer handles it for you. However, it has important consequences. Each recursive call uses memory for its frame. If you recurse too deeply, you can run out of stack memory, causing a stack overflow error. This is why recursion has a practical depth limit, usually in the thousands of calls.\n\nThe call stack also explains the order of execution. Recursive functions work by going deep into recursion until hitting the base case, then unwinding back up. For example, with factorial(5), the execution goes: factorial(5) â†’ factorial(4) â†’ factorial(3) â†’ factorial(2) â†’ factorial(1) [base case]. Then it unwinds: 1 is returned to factorial(2), which computes 2*1=2 and returns to factorial(3), which computes 3*2=6 and returns to factorial(4), which computes 4*6=24 and returns to factorial(5), which computes 5*24=120 and returns.\n\nSome recursive functions make multiple recursive calls. For example, Fibonacci(5) calls Fibonacci(4) and Fibonacci(3). Each of those makes more recursive calls. This creates a tree-like pattern of calls, with exponentially many calls for large inputs. This is why some recursive algorithms are inefficient without optimization techniques like memoization.",
      "codeExample": "// Fibonacci - multiple recursive calls per function\nint fib(int n) {\n    if (n <= 1) return n;      // BASE CASE\n    return fib(n-1) + fib(n-2); // TWO recursive calls\n}\n\n// Call stack visualization for fib(4):\n// fib(4) calls fib(3) and fib(2)\n//   fib(3) calls fib(2) and fib(1)\n//     fib(2) calls fib(1) and fib(0)\n//       fib(1) returns 1\n//       fib(0) returns 0 â†’ fib(2) returns 1\n//     fib(1) returns 1 â†’ fib(3) returns 2\n//   fib(2) calls fib(1) and fib(0)\n//     fib(1) returns 1\n//     fib(0) returns 0 â†’ fib(2) returns 1\n// fib(4) returns 3\n\n// Tree traversal - natural recursion use case\nvoid traverseTree(TreeNode* node) {\n    if (node == NULL) return;  // BASE CASE\n    \n    // Process current node\n    printf(\"%d \", node->value);\n    \n    // Recursively traverse left and right subtrees\n    traverseTree(node->left);   // RECURSIVE CALLS\n    traverseTree(node->right);\n}",
      "visualization": {
        "type": "flow",
        "title": "Recursive Call Stack Pattern",
        "description": "How stack frames push and pop during recursion",
        "data": {
          "steps": [
            {"label": "factorial(3)", "description": "Call stack size: 1"},
            {"label": "â†’ factorial(2)", "description": "Call stack size: 2"},
            {"label": "â†’ factorial(1)", "description": "Call stack size: 3"},
            {"label": "Return 1", "description": "Base case reached", "hasNext": false}
          ]
        }
      }
    }
  ],
  "codeEditor": {
    "defaultCode": "#include <stdio.h>\n\nint factorial(int n) {\n    if (n <= 1) return 1;        // Base case\n    return n * factorial(n - 1); // Recursive call\n}\n\nint main() {\n    printf(\"Factorial of 5: %d\\n\", factorial(5));\n    printf(\"Factorial of 10: %d\\n\", factorial(10));\n    \n    return 0;\n}",
    "language": "c"
  },
  "challenges": [
    {
      "id": "challenge_1",
      "title": "Sum of N Numbers",
      "description": "Write a recursive function that returns the sum of first N natural numbers (1+2+3+...+N)",
      "hints": [
        "Base case: if n == 0, return 0",
        "Recursive: return n + sum(n-1)",
        "Call sum(5) for answer 15"
      ],
      "solution": "int sum(int n) {\n    if (n == 0) return 0;\n    return n + sum(n - 1);\n}"
    },
    {
      "id": "challenge_2",
      "title": "String Reversal",
      "description": "Write a recursive function to print a string in reverse",
      "hints": [
        "Base case: if we reach null terminator, stop",
        "First go to end (recursion)",
        "Then print on way back"
      ],
      "solution": "void reverse(char *str) {\n    if (*str == '\\0') return;\n    reverse(str + 1);\n    printf(\"%c\", *str);\n}"
    }
  ],
  "achievements": [
    "Recursion Expert",
    "Stack Master"
  ]
}
